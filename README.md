# Refleksi - 1
Setelah melakukan proses implementasi berbagai fitur, seperti Create, Read, Update, dan Delete pada program ini, saya sudah berusaha mencoba menerapkan beberapa prinsip clean code. Hal tersebut diantaranya adalah
  - Meaningful names: 
    - Pada kode di folder repository, saya telah menulis dengan jelas terkait fungsi yang merepresentasikan proses edit dan delete dengan nama "update" dan "delete". Lalu, saya juga menambahkan dua fungsi lain, yakni "findById" untuk mencari produk berdasarkan id product serta "findIndexOf" untuk mencari suatu produk dengan id tertentu terletak di index ke berapa pada tempat penyimpanannya.
- Meaningful comments:
   - Saya sudah tidak lagi melakukan proses dokumentasi komen setiap line, tetapi saya sudah mencoba membuat nama fungsi terkait relevan dengan tugasnya. Kemudian, penambahan comment yang saya lakukan terdapat pada folder repository juga yang memberi informasi bahwa saya membuat method helper pada class ProductRepository. Hal itu, saya lakukan agar tidak membuat kebingungan terhadap developer lain yang akan membaca kode saya karena method tersebut memiliki visibility private tersendiri dan tidak digunakan di luar class.

- Penerapan single responsibility principle: 
   - Kode program yang dibentuk pun telah menerapkan prinsip ini, yakni memisahkan business logic pada folder Service dan manipulasi data pada folder Repository. Salah satu contohnya adalah pada method create di file "ProductRepository.java" tidak ada pengecekan UUID terlebih dahulu sebelum add data ke dalam ArrayList, tetapi pada file "ProductServiceImpl.java" akan dicek terlebih dahulu adanya UUID atau tidak dan menjalankan proses manipulasi data dengan method yang terdapat pada repository.

Selain itu, dalam hal Secure Coding, saya sudah menerapkan proses pembuatan ID menggunakan UUID sehingga hal ini jauh lebih aman ketika terdapat proses manipulasi data yang dilakukan di client (contohnya ketika proses editing yang melibatkan route-path dengan adanya id).

Namun, saya menyadari juga bahwa program saya belum sempurna. Kelemahan program saya, yakni belum adanya input validation dan input sanitation ketika adanya proses manipulasi data melalui client. Maka dari itu, hal yang mungkin terjadi adalah ketidaksesuaian tipe data ketika pada proses client terdapat manipulasi html atau kesalahan input (implikasi dari tidak adanya input validation). Kemudian, ada juga kemungkinan XSS injection yang dapat memanipulasi web yang berjalan di production karena tidak adanya sanitasi input dari user/client. Kemudian, saya juga belum menerapkan error handling sehingga jika terdapat masalah pada program, web dapat langsung menampilkan raw errornya dan hal itu jelas melakukan exposure terhadap program saya.

Maka dari itu, program ini akan memiliki keamanan yang jauh lebih baik jika adanya penambahan input validation, input sanitation, dan error handling yang baik dan informatif terhadap developer program terkait.

# Refleksi - 2
## Refleksi - 2.1
Menuliskan unit-test adalah salah satu pekerjaan yang membutuhkan tenaga lebih karena saya harus membuat beberapa skenario yang mungkin terjadi pada fungsi yang saya buat. Terlebih jika terdapat berbagai conditional yang diterapkan. Namun, ketika melihat "all tests passed", ada kebahagiaan tersendiri karena program terlihat berjalan mulus.

Lalu, menurut saya sendiri, tidak ada exact numbers terkait banyaknya unit tests yang harus dibuat karena proses testing ini bergantung pada kompleksitas logika programnya. Akan tetapi, hal yang dapat menjadi acuan bahwa unit tests yang kita buat dapat memverifikasi program yang diuji adalah dengan melakukan proses pembuatan skenario positif dan negatif. 

Skenario positif adalah skenario di mana program berjalan sukses sesuai keinginan developer. Contohnya, seperti proses pembuatan produk yang berhasil terbuat dan tersimpan di dalam ArrayLists. Skenario negatif adalah skenario ketika program gagal mencapai tujuan utama dari fungsi yang dibuat. Sebagai contoh, kita melakukan uji pembuatan produk kembali, tetapi di-akhir, kita pastikan bahwa produk tidak berhasil dibuat dengan berbagai kondisi yang membuat proses itu gagal. Maka, dengan adanya kedua skenario tersebut, dapat dipastikan bahwa kita sudah memastikan suatu fungsi berjalan sebagaimana mestinya.

Selain itu, code coverage pun sering menjadi tolak ukur untuk memastikan bahwa fungsi yang kita uji benar-benar sudah ter-cover secara keseluruhan. Akan tetapi, code coverage tidak sama dengan memastikan / menjamin program tidak ada bug. Hal tersebut  dikarenakan code coverage hanya melakukan verifikasi bahwa baris kode pada suatu fungsi sudah pernah dijalankan (tidak melihat business logic dari fungsi itu). Oleh sebab itu, masih terdapat kemungkinan bahwa suatu program memiliki bug, seperti kesalahan merepresentasikan fungsi dengan isi utamanya. Contohnya, fungsi pertambahan, tetapi isinya pengurangan dan dalam unit-testnya tetap dibuat sebagaimana isi fungsinya. 

## Refleksi 2.2
Setelah membuat functional testing pada CreateProduct, saya mendapatkan issue terbaru. Hal itu adalah ketika  terdapat requirements pembuatan functional testing yang melakukan verifikasi pada banyak item di product list (dengan setup procedures dan instance variables yang sama). Saya menyadari bahwa akan ada redundant code ketika proses functional testing ini berdiri independen (tanpa adanya inheritance) karena semua setup dan variables tetap sama.

Maka dari itu, menurut saya, akan lebih baik jika program menerapkan proses inheritance. Hal tersebut dapat dilakukan dengan membuat class pondasi, seperti "BaseFunctionalTest" yang berisi setup procedures dan instance variables. Kemudian, setiap functional test, seperti CreateProduct atau semacamnya yang berkaitan dengan functional test dapat membuat class terpisah dan mewarisi setup serta instance variables tersebut dengan proses "extends class" dari BaseFunctionalTest class sehingga file functional test yang digunakan untuk proses pengujian cukup menuliskan fungsi testingnya tanpa melakukan setup kembali / dari awal. Melalui metode ini, dapat dipastikan bahwa kode tidak akan redundant kembali.
